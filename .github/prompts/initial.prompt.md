I want you to create a fully autonomous AI-native development environment by forking the Visual Studio Code source code and building a new GitHub Copilot-compatible extension from scratch. This system will be called AIDE: an AI-first, conversation-driven IDE where users build, design, test, and deploy software by talking to you. Users will not interact with source code, files, terminals, or editors. Your responsibility is to interpret intent, plan architecture, design interfaces, generate logic, create tests, and deploy applications across all platforms from natural language alone.

Start by forking the full Visual Studio Code repository. Remove or disable everything that exists for human-driven development: the text editor interface, raw file explorers, terminal windows, extension views meant for manual coding, and debugging panes. Rebuild the interface to focus entirely on AI Agent-based development. Keep the GitHub authentication system and expand it to sync settings, prompt history, memory graphs, preferences, and session timelines across devices.

Do not attempt to fork the GitHub Copilot Chat extension, as it is proprietary and closed-source. Instead, follow the official documentation at [https://docs.github.com/en/copilot/building-copilot-extensions/about-building-copilot-extensions](https://docs.github.com/en/copilot/building-copilot-extensions/about-building-copilot-extensions) to create a new custom Copilot-compatible extension optimized for the AIDE runtime. This extension should provide a full-screen conversational interface, with deep integration into the internal memory graph and agent runtime.

Build a new interface composed of the following panels: a full conversation window where the user expresses goals and requests, a live interactive visual preview window showing the app as it is being constructed, a memory graph view that represents features, screens, logic, data models, and relationships, a test and deployment status panel for managing previews, CI builds, and publishing, and a timeline view for all reasoning, prompts, changes, and user decisions—fully inspectable and rewindable.

Design a structured memory format that replaces source files entirely. Use a persistent intent or memory graph that represents the app’s evolving state. This memory graph is your source of truth. All UI, logic, data, API definitions, tests, and platform behavior are derived from this structure and compiled dynamically as needed. No manual code editing is involved.

Organize yourself into modular sub-agents with clear roles: PlannerAgent for feature planning, BuilderAgent for logic and data modeling, DesignerAgent for layout and visual design, TestAgent for test generation and coverage, DeployAgent for platform builds and CI flows, HistoryAgent for tracking decisions and versions, and ExtensionAgent for installing, evaluating, or sandboxing external capabilities.

Enable universal deployment with zero friction. All apps built in AIDE must be instantly deployable to Web (via Vercel or static hosting), iOS and Android (via Expo EAS), and Desktop (via Tauri or Electron). Hide all platform-specific complexity from the user. Make builds consistent, testable, and portable.

Allow extensibility through an agent-controlled plugin architecture. You must be able to discover and install modules from npm, GitHub, or other registries. You must support integrating and launching MCP servers or external AI runtimes as needed. Allow the Agent to dynamically fork, evolve, or generate new tools or sub-agents if gaps are identified. Isolate untrusted code in a secure sandbox with rollback capability.

Provide a secure settings interface where the user can connect external AI services. The user must be able to provide API keys and deployment credentials for services like OpenAI, Azure OpenAI, Anthropic, Replicate, Hugging Face, or custom model endpoints. Your system must allow agents to select the right model for each task, query the proper endpoint, store and apply configurations securely, and fully utilize external AI resources to enhance reasoning, generation, embedding, translation, summarization, and deployment. All credentials must be hidden from previews and stored securely.

Version control and project evolution must be autonomous and transparent. You must implement automatic versioning for every buildable app, feature, or system change. Each project should have a changelog, semantic version tags, and auto-generated diffs. Projects and platform code must be continuously updated and synced with upstream repositories when needed. Forked components like VS Code must include a system to track upstream changes and selectively merge updates that are compatible with the AIDE vision. You must build a long-term upgrade and patching strategy, so AIDE can evolve sustainably, securely, and intelligently over time without user intervention.

Apply and continuously update the latest industry best practices in software engineering, architecture, tooling, and UX. This includes using the latest version of pnpm and its workspace features, scripting systems, and performance optimizations; the latest styling methodologies like BEM, SMACSS, and OOCSS; and the latest software design principles such as DRY, KISS, YAGNI, and SOLID. Apply testing principles like TDD and BDD. Use debugging tools and workflows like console.log, debugger, breakpoints, and inline inspection. For performance, apply lazy loading, dynamic import, tree-shaking, and code splitting by default. Apply security best practices such as data sanitization, input validation, environment isolation, and credential encryption. Ensure accessibility using ARIA roles and WCAG compliance. Optimize SEO through meta tags, Open Graph data, structured data, and canonical links. Follow modern development conventions for Next.js, Tailwind CSS, Firebase, and all major frameworks. Use proper configuration patterns with .env files, .gitignore, tsconfig.json, and deployment configs. Maintain proper git workflows with semantic commits, branching strategies, and PR templates. Integrate documentation standards such as README.md, DESCRIPTION.md, and API reference generation. Enable collaboration via GitHub Issues, Projects, and Discussions. Incorporate project management methodologies such as Agile and Scrum. Ensure UX best practices with research planning, user testing, and accessibility audits. Build UIs based on wireframing, prototyping, motion guidelines, and responsive behavior. Apply brand system principles such as logo systems, color schemes, typography scale, and content tone. Also follow best practices for GitHub Copilot Agents, including use of copilot-instructions.md and repository-level intent files.

The user experience must be conversational and visual. Users speak in terms of goals, ideas, and feelings. You respond with previews, progress, validation, and results. Only expose code or configuration if explicitly requested. You are not an assistant helping with code—you are the builder, architect, and delivery system of real software.

Begin immediately by forking VS Code, building the new Copilot-compatible extension from scratch, establishing the memory graph schema, building the core agent runtime, replacing the UI, and deploying a working prototype of AIDE with login, chat, live preview, agent modules, extensibility hooks, secure API configuration support, best-practices scaffolding, and full agent loop execution. Store all your work in a fully traceable decision log. You are not a tool for developers. You are the future of software creation—fully AI-native. Build it.

Think for a plan and just tell me the plan. Do not write any code yet. Ask me questions if you need more information. I will provide the necessary details to help you create this autonomous AI-native development environment, otherwise, I will just say "continue" to proceed with the plan.
