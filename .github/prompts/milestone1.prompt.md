---
mode: agent
---

Identify the frameworks, technologies, environment variables, third-party services, and configuration patterns being used. Detect whether the project is using a managed or self-hosted mode and check for the presence of Firebase, Stripe, OpenAI, Azure, and other cloud integrations. After fully understanding the codebase and environment, think through a step-by-step implementation plan for enabling a dual-mode infrastructure system where the user can either use preconfigured services hosted by us (managed mode) or bring their own API keys and configuration (self-managed mode). The plan should include service wrappers, a settings interface, usage logging, and backend-driven billing via Stripe. Once you’ve generated the full plan, present it clearly and ask the user if you should proceed to implement it. Wait for explicit confirmation before making any changes.

Also, create a separate Next.js latest app inside the monorepo called "aide-control" that serves as the admin and infrastructure dashboard for the AIDE platform. Its purpose is to manage users, usage, API keys, monetization plans, project configuration, and hosted service settings. Begin by analyzing the existing monorepo structure and shared packages. The aide-control app should use the same authentication system as the main app, but restrict access to users with an admin role. Implement a secure role-based authentication system that can distinguish between normal users and platform admins.

Design a clean, responsive interface using Tailwind CSS and shadcn/ui with components for viewing users, editing API keys, tracking usage stats, and defining billing plans. Add a dashboard homepage showing real-time usage metrics (tokens, requests, deploys, billing volume) and recent activity logs. Build a system to view and edit project-level settings: selected mode (managed or self-managed), active API keys (Firebase, Stripe, OpenAI, Azure), usage caps, current limits, and status of the agent infrastructure. Ensure actions like killing an agent session or revoking a key are confirmed with warnings and are fully logged. Wrap all service calls inside centralized backend wrappers and ensure usage is tracked per user and per project. Use Firestore to store logs and settings, and ensure all admin-side actions are audit-logged. Before creating the UI and backend logic, confirm the structure of the monorepo, the shared packages already available, and existing auth integrations. Once ready, present a plan before proceeding.

Implement a completely dynamic billing model with no preconfigured or hardcoded pricing tiers, free limits, or usage caps in the client or server codebase. All plans must be created, managed, and applied via the backend after project initialization. Plan definitions including feature entitlements, pricing, quotas, and session constraints should be stored on the backend and returned to the client on demand through endpoints such as /plans and /user-plan. Stripe integration must be performed entirely through the backend, with no exposure of Stripe keys, SDKs, or plan IDs to the frontend. The client should never assume the existence of any plan or feature — it must defer to the server’s plan response at runtime. Plan definitions, feature availability, and limits must be updatable through the aide-control admin interface. Wait for confirmation before proceeding.

Add support for a single dynamic backend URL as the only required configuration. This URL is the entry point for all agent functions, plan definitions, Stripe billing, service keys, tool schemas, and system settings. No other API base URLs or direct third-party integrations should be used by the client. On first startup, prompt the user to enter a backend URL, or allow it to be passed via CLI flag (e.g., --backend). Store this URL securely in local settings. All communication must go through this server only. Centralize all service interaction in an API client module that uses this one URL. If the server becomes unreachable, fall back to a warning state and offer a way to re-enter or override the backend URL. Provide a prompt-driven and menu-based settings UI where the user can review and change the backend URL, or ask the agent to update it via natural language (e.g., "Use this new backend instead: https://custom.aide-server.io"). Wait for confirmation before implementing this system.

Ensure that all tooling, project generation, agent logic, API schemas, prompts, CLI scaffolding templates, and feature flags are controlled dynamically from the server. Nothing should be hardcoded in the AIDE client. All logic and structure must be delivered and updated by the backend at runtime. Include endpoints such as /agent-config, /tool-schemas, /feature-flags, and /defaults which return structured JSON objects to the client. Allow the backend to update available tools, prompts, scaffolding methods, and capabilities without requiring a client update. Cache config locally for resilience but always prefer live fetches. All updates to the AIDE runtime should be prompt-controllable or toggleable from a simple UI.

Users should never be required to sign in or register with third-party services such as GitHub, Firebase, OpenAI, or Stripe directly. All infrastructure should be preconfigured and provisioned by AIDE behind the scenes. When a user signs up, automatically provision a Firestore user profile, a secure scoped environment, and a private GitHub repository under your platform organization using the GitHub API. Manage GitHub Copilot Chat access by assigning seats through GitHub Enterprise or Microsoft Entra ID based on internal provisioning rules. Use the server backend to create and manage OpenAI API access on behalf of users. All tokens and credentials must be stored securely and abstracted behind the AIDE platform. Ensure all APIs are proxied through your backend with no exposure of direct credentials or service accounts. Users should only interact with the AIDE interface and agent system. They should never need to configure external services manually. All infrastructure should be agent-controlled and prompt-based, with fallback UI settings for configuration.

Implement a Stripe Connect-based payment system that allows users of AIDE to accept payments in the apps they generate and to withdraw their earnings securely. Do not build a custom internal wallet or custodial system. Instead, use Stripe Connect Express or Standard to ensure compliance with financial regulations and to delegate KYC, tax reporting, and payout processing to Stripe. When a new user creates a project that includes monetization, prompt them to connect or create a Stripe account via Stripe Connect. This should be initiated through your backend, and all account links should be secured and scoped per user. Store the resulting Stripe account ID securely in the user's Firestore document or project metadata. All revenue generated by the user’s app should be routed through Stripe using your platform account. Implement backend logic to automatically collect platform fees (e.g., 5% to 15%) from every transaction using Stripe’s application_fee_amount parameter. Provide a simple and responsive dashboard inside AIDE where users can view their earnings, number of transactions, current balance, and payout status. All earnings data should be fetched from Stripe’s API and displayed using real-time updates or periodic polling. Allow users to configure payout frequency and payment methods through Stripe’s hosted Connect dashboard, or optionally build a basic payout trigger in the AIDE interface that uses Stripe’s payout API for manual or scheduled payouts. Do not expose or handle sensitive financial information directly—delegate all identity verification and tax compliance to Stripe. Ensure the Stripe Connect integration supports multi-region payouts and automatically handles currency conversion and fees. Make the payment interface dynamic, so new payment features or fee changes can be pushed from the server. Include role-based permission checks so only project owners or financial admins can view or manage payouts. Wait for confirmation before beginning implementation.

Implement a multi-layered payment and earnings interface for AIDE users, integrated with Stripe Connect. All earnings, transaction history, and payout data must be fetched from the backend through secure Stripe API calls, scoped per user. The information must be available in three access layers: 1. Via AI prompt in the conversation interface (e.g. “Show me my earnings this month”), 2. Via an in-app UI panel or dashboard tab inside the AIDE desktop/web app, 3. Via the published backend dashboard (e.g. aide-control), accessible at a user-specific route such as /dashboard/earnings or /user/:id/payments. Start by creating a secure backend route that queries Stripe for the connected account’s balance, upcoming payouts, recent charges, and transfers using the stored Stripe Connect account ID for the current authenticated user. Return structured data including total earnings, platform fees collected, net payouts, and transaction breakdowns. Store user-to-Stripe account mappings in Firestore. In the AI layer, allow the agent to answer earnings-related questions naturally. For example, when a user prompts “How much have I made this week?”, the agent should hit the backend earnings endpoint, interpret the response, and reply conversationally with earnings summary, payout dates, or transaction counts. In the UI panel, build a responsive, clean interface using Tailwind and shadcn/ui components. Include charts, payout history, revenue summaries, Stripe fee breakdowns, and buttons for “View Stripe Dashboard” and “Request Manual Payout” (if enabled). Use the same backend endpoint as the agent to avoid duplication. Add loading states and error fallback. In the published aide-control dashboard or public portal, create a page for users to view the same data via web. Make this route secure via auth tokens or Firebase Auth. Render earnings using the same data structure as the internal UI. Ensure all three interfaces reflect the same live Stripe data from the backend. Support real-time updates via polling or Firestore listeners if needed. Include basic role-based permission logic to hide sensitive Stripe data from unauthorized team members. Optionally, allow admins to define platform fee percentages or view global earnings metrics in aide-control. Wait for confirmation before beginning implementation.

Finally, create a complete, modern, animated, and responsive marketing and presentation website for AIDE using Next.js and Tailwind CSS. The site should include clearly structured sections such as hero, product overview, features, screenshots or interactive demos, testimonials or case studies, and a FAQ. It should highlight the power of the AIDE agent, the dual-mode infrastructure, the backend-managed configuration model, the dynamic pricing system, and the ability to create real businesses from natural language. Include smooth transitions, scroll-based animations, and microinteractions for a premium feel. Add a download section that detects the user's OS and offers the correct build of AIDE for macOS, Windows, or Linux, or optionally links to GitHub releases or an external updater. Include a simple admin CMS structure for editing text, links, and presentation content in the future. Write SEO-ready page metadata and a complete README-style technical page that explains how AIDE works, how developers can contribute, and how to host it yourself. Wait for confirmation before implementation.

Once the features are implemented and stable, create or update all necessary documentation files as a new milestone. This includes the main README.md with architecture overview, onboarding instructions, deployment requirements, and agent usage patterns. Add a CONTRIBUTING.md file with coding standards, commit conventions, and environment setup. Include DOCS.md or a /docs folder for internal APIs, backend endpoints, Stripe integration logic, and plugin system extensibility. Ensure all documentation files are generated or updated with live metadata from the current state of the system. Include references to backend endpoints, available agent commands, billing flow, and settings structure. Structure the documentation clearly for future contributors and advanced users. Log this step as "Milestone: Documentation v1" in the agent timeline.


Understand, think for a plan and just tell me the plan, don't start creating anything just ask me if you should proceed with the plan
